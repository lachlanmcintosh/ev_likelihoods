

# This file was *autogenerated* from the file matrix_gen.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0)
import sys

var('u,d')
R = ZZ['s']; (s,) = R._first_ngens(1)
def f(s): return d+(_sage_const_1 -u-d)*s+u*s**_sage_const_2 

# m[i,j] tells you the probability of going from copy number i to copy number j in 1 generation
# m[i,j]^k tells you the probability of going from copy number i to copy number j in k generations

poly = f(s)
path_length = int(sys.argv[_sage_const_1 ])
dimension = _sage_const_1 +_sage_const_2 **(path_length) 
m = matrix(QQ['u,d'],dimension,dimension)

# base case
m[_sage_const_0 ,_sage_const_0 ] = _sage_const_1 

# other cases
# WE ONLY NEED TO GO TO ONE POWER LESS THAT THE MAX COPY NUMBER STATE BECAUSE
for i in range(_sage_const_1 ,_sage_const_2 **(path_length-_sage_const_1 )+_sage_const_1 ):
  print(i)
  my_coefs = poly.coefficients(s,sparse=False)
  for j in range(len(my_coefs)):
    m[i,j] = my_coefs[j]
  poly = poly * f(s) 

outfile = "MATRICES/matrix_p"+str(path_length)+"_v4"
save(m,outfile)



